---
kindle-sync:
  bookId: '53530'
  title: >-
    Learning Domain-Driven Design: Aligning Software Architecture and Business
    Strategy
  author: Vlad Khononov
  asin: B09J2CMJZY
  lastAnnotatedDate: '2023-06-27'
  bookImageUrl: 'https://m.media-amazon.com/images/I/81WJbw5XJbL._SY160.jpg'
  highlightsCount: 251
---
# Learning Domain-Driven Design
## Metadata
* Author: [Vlad Khononov](https://www.amazon.comundefined)
* ASIN: B09J2CMJZY
* Reference: https://www.amazon.com/dp/B09J2CMJZY
* [Kindle link](kindle://book?action=open&asin=B09J2CMJZY)

## Highlights
There is no sense in talking about the solution before we agree on the problem, and no sense talking about the implementation steps before we agree on the solution. — location: [307](kindle://book?action=open&asin=B09J2CMJZY&location=307) ^ref-7800

---
strategic design and tactical design. — location: [315](kindle://book?action=open&asin=B09J2CMJZY&location=315) ^ref-57325

---
The strategic aspect of DDD deals with answering the questions of “what?” and “why?”—what software we are building and why we are building it. — location: [315](kindle://book?action=open&asin=B09J2CMJZY&location=315) ^ref-34142

---
The tactical part is all about the “how”—how each component is implemented. — location: [316](kindle://book?action=open&asin=B09J2CMJZY&location=316) ^ref-8127

---
business domain defines a company’s main area of activity. — location: [350](kindle://book?action=open&asin=B09J2CMJZY&location=350) ^ref-45901

---
subdomain is a fine-grained area of business activity. — location: [363](kindle://book?action=open&asin=B09J2CMJZY&location=363) ^ref-58641

---
All of a company’s subdomains form its business domain: the service it provides to its customers. — location: [364](kindle://book?action=open&asin=B09J2CMJZY&location=364) ^ref-38385

---
Domain-driven design distinguishes between three types of subdomains: core, generic, and supporting. — location: [372](kindle://book?action=open&asin=B09J2CMJZY&location=372) ^ref-56004

---
A core subdomain is what a company does differently from its competitors. — location: [374](kindle://book?action=open&asin=B09J2CMJZY&location=374) ^ref-44129

---
profitability. To maintain a competitive advantage, core subdomains involve inventions, smart optimizations, — location: [383](kindle://book?action=open&asin=B09J2CMJZY&location=383) ^ref-16789

---
A core subdomain that is simple to implement can only provide a short-lived competitive advantage. Therefore, core subdomains are naturally complex. — location: [393](kindle://book?action=open&asin=B09J2CMJZY&location=393) ^ref-44689

---
it should be hard for competitors to copy or imitate the company’s solution. — location: [401](kindle://book?action=open&asin=B09J2CMJZY&location=401) ^ref-52781

---
Generic subdomains are business activities that all companies are performing in the same way. — location: [431](kindle://book?action=open&asin=B09J2CMJZY&location=431) ^ref-46853

---
Like core subdomains, generic subdomains are generally complex and hard to implement. However, generic subdomains do not provide any competitive edge for the company. — location: [441](kindle://book?action=open&asin=B09J2CMJZY&location=441) ^ref-53774

---
As the name suggests, supporting subdomains support the company’s business. — location: [449](kindle://book?action=open&asin=B09J2CMJZY&location=449) ^ref-6530

---
contrary to core subdomains, supporting subdomains do not provide any competitive advantage. — location: [455](kindle://book?action=open&asin=B09J2CMJZY&location=455) ^ref-61785

---
Only core subdomains provide a competitive advantage to a company. — location: [472](kindle://book?action=open&asin=B09J2CMJZY&location=472) ^ref-25583

---
Usually, a company wouldn’t mind its competitors copying its supporting subdomains—this won’t affect its competitiveness in the industry. — location: [488](kindle://book?action=open&asin=B09J2CMJZY&location=488) ^ref-59346

---
The complex problems are not limited to delivering services to consumers. A complex problem can be, for example, making the business more optimized and efficient. — location: [498](kindle://book?action=open&asin=B09J2CMJZY&location=498) ^ref-6962

---
Generic subdomains are much more complicated. — location: [509](kindle://book?action=open&asin=B09J2CMJZY&location=509) ^ref-47886

---
These solutions are neither simple nor trivial. Consider, for example, encryption algorithms or authentication mechanisms. — location: [513](kindle://book?action=open&asin=B09J2CMJZY&location=513) ^ref-37022

---
Core subdomains are complex. They should be as hard for competitors to copy as possible—the company’s profitability depends on it. — location: [517](kindle://book?action=open&asin=B09J2CMJZY&location=517) ^ref-37903

---
At times it may be challenging to differentiate between core and supporting subdomains. Complexity is a useful guiding principle. Ask whether the subdomain in question can be turned into a side business. Would someone pay for it on its own? If so, this is a core subdomain. — location: [524](kindle://book?action=open&asin=B09J2CMJZY&location=524) ^ref-39780

---
If a generic solution exists for a supporting subdomain’s functionality, the resultant subdomain type depends on whether it’s simpler and/or cheaper to integrate the generic solution than it is to implement the functionality from scratch. — location: [538](kindle://book?action=open&asin=B09J2CMJZY&location=538) ^ref-64598

---
Core subdomains have to be implemented in-house. They cannot be bought or adopted; that would undermine the notion of competitive advantage, as the company’s competitors would be able to do the same. — location: [569](kindle://book?action=open&asin=B09J2CMJZY&location=569) ^ref-44575

---
Since generic subdomains are hard but already solved problems, it’s more cost-effective to buy an off-the-shelf product or adopt an open source solution than invest time and effort into implementing a generic subdomain in-house. — location: [581](kindle://book?action=open&asin=B09J2CMJZY&location=581) ^ref-1160

---
simplicity of the business logic makes supporting subdomains a good candidate for outsourcing. — location: [591](kindle://book?action=open&asin=B09J2CMJZY&location=591) ^ref-38137

---
Domain experts are subject matter experts who know all the intricacies of the business that we are going to model and implement in code. — location: [767](kindle://book?action=open&asin=B09J2CMJZY&location=767) ^ref-23383

---
Domain experts represent the business. They are the people who identified the business problem in the first place and from whom all business knowledge originates. — location: [770](kindle://book?action=open&asin=B09J2CMJZY&location=770) ^ref-22746

---
As a rule of thumb, domain experts are either the people coming up with requirements or the software’s end users. — location: [772](kindle://book?action=open&asin=B09J2CMJZY&location=772) ^ref-3695

---
The transaction script pattern is well adapted to the most straightforward problem domains in which the business logic resembles simple procedural operations. — location: [2010](kindle://book?action=open&asin=B09J2CMJZY&location=2010) ^ref-49771

---
The transaction script pattern naturally fits supporting subdomains where, by definition, the business logic is simple. — location: [2021](kindle://book?action=open&asin=B09J2CMJZY&location=2021) ^ref-29039

---
The main advantage of the transaction script pattern is its simplicity. — location: [2023](kindle://book?action=open&asin=B09J2CMJZY&location=2023) ^ref-19675

---
As a result, the active record objects are coupled to an object-relational mapping (ORM) or some other data access framework. — location: [2055](kindle://book?action=open&asin=B09J2CMJZY&location=2055) ^ref-58274

---
The pattern’s goal is to encapsulate the complexity of mapping the in-memory object to the database’s schema. — location: [2092](kindle://book?action=open&asin=B09J2CMJZY&location=2092) ^ref-13274

---
In addition to being responsible for persistence, the active record objects can contain business logic; — location: [2093](kindle://book?action=open&asin=B09J2CMJZY&location=2093) ^ref-54440

---
Because an active record is essentially a transaction script that optimizes access to databases, this pattern can only support relatively simple business logic, such as CRUD operations, which, at most, validate the user’s input. — location: [2098](kindle://book?action=open&asin=B09J2CMJZY&location=2098) ^ref-52721

---
A domain model is an object model of the domain that incorporates both behavior and data. — location: [2232](kindle://book?action=open&asin=B09J2CMJZY&location=2232) ^ref-23405

---
DDD’s tactical patterns—aggregates, value objects, domain events, and domain services—are the building blocks of such an object model. — location: [2236](kindle://book?action=open&asin=B09J2CMJZY&location=2236) ^ref-28837

---
The model should be devoid of any infrastructural or technological concerns, such as implementing calls to databases or other external components — location: [2244](kindle://book?action=open&asin=B09J2CMJZY&location=2244) ^ref-13049

---
This restriction requires the model’s objects to be plain old objects, objects implementing business logic without relying on or directly incorporating any infrastructural components or frameworks. — location: [2245](kindle://book?action=open&asin=B09J2CMJZY&location=2245) ^ref-55911

---
A value object is an object that can be identified by the composition of its values. — location: [2256](kindle://book?action=open&asin=B09J2CMJZY&location=2256) ^ref-25991

---
Therefore, no explicit identification field is needed to identify colors. — location: [2271](kindle://book?action=open&asin=B09J2CMJZY&location=2271) ^ref-23416

---
The ColorId field shown in Figure 6-1 is not only redundant, but actually creates an opening for bugs. — location: [2272](kindle://book?action=open&asin=B09J2CMJZY&location=2272) ^ref-47147

---
Compare the following alternative design of the same object, this time leveraging value objects: — location: [2336](kindle://book?action=open&asin=B09J2CMJZY&location=2336) ^ref-64001

---
Second, there is no need to validate the values before the assignment, as the validation logic resides in the value objects themselves. — location: [2393](kindle://book?action=open&asin=B09J2CMJZY&location=2393) ^ref-14791

---
Value objects shine brightest when they centralize the business logic that manipulates the values. — location: [2394](kindle://book?action=open&asin=B09J2CMJZY&location=2394) ^ref-41818

---
value objects express the business domain’s concepts: they make the code speak the ubiquitous language. — location: [2396](kindle://book?action=open&asin=B09J2CMJZY&location=2396) ^ref-41594

---
The following example demonstrates the power of a value object when it encapsulates all of the business logic that manipulates the data and produces new instances of the value object: — location: [2448](kindle://book?action=open&asin=B09J2CMJZY&location=2448) ^ref-62288

---
As you can see in the preceding examples, value objects eliminate the need for conventions—for example, the need to keep in mind that this string is an email and the other string is a phone number—and — location: [2467](kindle://book?action=open&asin=B09J2CMJZY&location=2467) ^ref-6747

---
Since a change to any of the fields of a value object results in a different value, value objects are implemented as immutable objects. — location: [2472](kindle://book?action=open&asin=B09J2CMJZY&location=2472) ^ref-21045

---
change to one of the value object’s fields conceptually creates a different value—a different instance of a value object. — location: [2474](kindle://book?action=open&asin=B09J2CMJZY&location=2474) ^ref-36116

---
it doesn’t modify the original instance but instantiates and returns a new one: — location: [2476](kindle://book?action=open&asin=B09J2CMJZY&location=2476) ^ref-20550

---
Since value objects are immutable, the value objects’ behavior is free of side effects and is thread safe. — location: [2607](kindle://book?action=open&asin=B09J2CMJZY&location=2607) ^ref-36164

---
From a business domain perspective, a useful rule of thumb is to use value objects for the domain’s elements that describe properties of other objects. This namely applies to properties of entities, — location: [2608](kindle://book?action=open&asin=B09J2CMJZY&location=2608) ^ref-24458

---
Other examples of using value objects include various statuses, passwords, and more business domain–specific concepts that can be identified by their values and thus do not require an explicit identification field. An especially important opportunity to introduce a value object is when modeling money and other monetary values. — location: [2610](kindle://book?action=open&asin=B09J2CMJZY&location=2610) ^ref-36439

---
An entity is the opposite of a value object. It requires an explicit identification field to distinguish between the different instances of the entity. — location: [2618](kindle://book?action=open&asin=B09J2CMJZY&location=2618) ^ref-46961

---
an identification field is needed to properly identify people: — location: [2640](kindle://book?action=open&asin=B09J2CMJZY&location=2640) ^ref-11376

---
The central requirement for the identification field is that it should be unique for each instance of the entity: — location: [2667](kindle://book?action=open&asin=B09J2CMJZY&location=2667) ^ref-9740

---
Furthermore, except for very rare exceptions, the value of an entity’s identification field should remain immutable throughout the entity’s lifecycle. — location: [2668](kindle://book?action=open&asin=B09J2CMJZY&location=2668) ^ref-24146

---
Contrary to value objects, entities are not immutable and are expected to change. — location: [2674](kindle://book?action=open&asin=B09J2CMJZY&location=2674) ^ref-29960

---
Another difference between entities and value objects is that value objects describe an entity’s properties. — location: [2675](kindle://book?action=open&asin=B09J2CMJZY&location=2675) ^ref-2713

---
we don’t implement entities independently, but only in the context of the aggregate pattern. — location: [2680](kindle://book?action=open&asin=B09J2CMJZY&location=2680) ^ref-62258

---
An aggregate is an entity: it requires an explicit identification field and its state is expected to change during an instance’s lifecycle. However, it is much more than just an entity. The goal of the pattern is to protect the consistency of its data. — location: [2682](kindle://book?action=open&asin=B09J2CMJZY&location=2682) ^ref-26621

---
the aggregate is a consistency enforcement boundary. — location: [2701](kindle://book?action=open&asin=B09J2CMJZY&location=2701) ^ref-59346

---
The aggregate’s logic has to validate all incoming modifications and ensure that the changes do not contradict its business rules. — location: [2701](kindle://book?action=open&asin=B09J2CMJZY&location=2701) ^ref-19273

---
From an implementation perspective, the consistency is enforced by allowing only the aggregate’s business logic to modify its state. All processes or objects external to the aggregate are only allowed to read the aggregate’s state. Its state can only be mutated by executing corresponding methods of the aggregate’s public interface. — location: [2702](kindle://book?action=open&asin=B09J2CMJZY&location=2702) ^ref-921

---
Alternatively, a command can be represented as a parameter object that encapsulates all the input required for executing the command: — location: [2729](kindle://book?action=open&asin=B09J2CMJZY&location=2729) ^ref-23225

---
its simplest form, an aggregate should hold a version field that will be incremented after each update: — location: [2800](kindle://book?action=open&asin=B09J2CMJZY&location=2800) ^ref-64507

---
All changes to the aggregate’s state should be committed transactionally as one atomic operation. — location: [2833](kindle://book?action=open&asin=B09J2CMJZY&location=2833) ^ref-25400

---
no system operation can assume a multi-aggregate transaction. A change to an aggregate’s state can only be committed individually, one aggregate per database transaction. — location: [2835](kindle://book?action=open&asin=B09J2CMJZY&location=2835) ^ref-36363

---
That’s why the pattern is named “aggregate”: it aggregates business entities and value objects that belong to the same transaction boundary. — location: [2854](kindle://book?action=open&asin=B09J2CMJZY&location=2854) ^ref-59226

---
Only the information that is required by the aggregate’s business logic to be strongly consistent should be a part of the aggregate. — location: [2920](kindle://book?action=open&asin=B09J2CMJZY&location=2920) ^ref-41187

---
The rule of thumb is to keep the aggregates as small as possible and include only objects that are required to be in a strongly consistent state by the aggregate’s business logic: — location: [2925](kindle://book?action=open&asin=B09J2CMJZY&location=2925) ^ref-5555

---
The reasoning behind referencing external aggregates by ID is to reify that these objects do not belong to the aggregate’s boundary, and to ensure that each aggregate has its own transactional boundary. — location: [2944](kindle://book?action=open&asin=B09J2CMJZY&location=2944) ^ref-15542

---
To decide whether an entity belongs to an aggregate or not, examine whether the aggregate contains business logic that can lead to an invalid system state if it will work on eventually consistent data. — location: [2946](kindle://book?action=open&asin=B09J2CMJZY&location=2946) ^ref-38021

---
domain event is a message describing a significant event that has occurred in the business domain. — location: [2992](kindle://book?action=open&asin=B09J2CMJZY&location=2992) ^ref-62554

---
Since domain events describe something that has already happened, their names should be formulated in the past tense. — location: [2997](kindle://book?action=open&asin=B09J2CMJZY&location=2997) ^ref-52111

---
Domain events are part of an aggregate’s public interface. An aggregate publishes its domain events. Other processes, aggregates, or even external systems can subscribe — location: [3014](kindle://book?action=open&asin=B09J2CMJZY&location=3014) ^ref-45676

---
the code must be based on the same language the developers use when they speak with one another and with domain experts. — location: [3068](kindle://book?action=open&asin=B09J2CMJZY&location=3068) ^ref-37909

---
Sooner or later, you may encounter business logic that either doesn’t belong to any aggregate or value object, or that seems to be relevant to multiple aggregates. In such cases, domain-driven design proposes to implement the logic as a domain service. — location: [3076](kindle://book?action=open&asin=B09J2CMJZY&location=3076) ^ref-16303

---
A domain service is a stateless object that implements the business logic. — location: [3082](kindle://book?action=open&asin=B09J2CMJZY&location=3082) ^ref-13993

---
The response time frame calculation logic requires information from multiple sources: the ticket, the assigned agent’s department, and the work schedule. That makes it an ideal candidate to be implemented as a domain service: — location: [3087](kindle://book?action=open&asin=B09J2CMJZY&location=3087) ^ref-33311

---
An aggregate can only be modified by its own methods. Its business logic encapsulates and protects business invariants, thus reducing the degrees of freedom. — location: [3244](kindle://book?action=open&asin=B09J2CMJZY&location=3244) ^ref-33943

---
The event-sourced domain model uses the event sourcing pattern to manage the aggregates’ states: instead of persisting an aggregate’s state, the model generates domain events describing each change and uses them as the source of truth for the aggregate’s data. — location: [3325](kindle://book?action=open&asin=B09J2CMJZY&location=3325) ^ref-44906

---
The table’s data documents the leads’ current states, but it misses the story of how each lead got to their current state. — location: [3430](kindle://book?action=open&asin=B09J2CMJZY&location=3430) ^ref-56094

---
The event sourcing pattern introduces the dimension of time into the data model. — location: [3436](kindle://book?action=open&asin=B09J2CMJZY&location=3436) ^ref-8712

---
Iterating an aggregate’s events and feeding them sequentially into the appropriate overrides of the Apply method will produce precisely the state representation — location: [3629](kindle://book?action=open&asin=B09J2CMJZY&location=3629) ^ref-65010

---
Pay attention to the Version field that is incremented after applying each event. Its value represents the total number of modifications made to the business entity. — location: [3631](kindle://book?action=open&asin=B09J2CMJZY&location=3631) ^ref-65267

---
The projection logic uses the LeadInitialized and ContactDetailsChanged events to populate the respective sets of the lead’s personal details. Other events are ignored since they do not affect the specific model’s state. — location: [3758](kindle://book?action=open&asin=B09J2CMJZY&location=3758) ^ref-40688

---
For the event sourcing pattern to work, all changes to an object’s state should be represented and persisted as events. — location: [3858](kindle://book?action=open&asin=B09J2CMJZY&location=3858) ^ref-43471

---
The database that stores the system’s events is the only strongly consistent storage: the system’s source of truth. The accepted name for the database that is used for persisting events is event store. — location: [3865](kindle://book?action=open&asin=B09J2CMJZY&location=3865) ^ref-31370

---
The event store should not allow modifying or deleting the events2 since it’s append-only storage. — location: [3868](kindle://book?action=open&asin=B09J2CMJZY&location=3868) ^ref-3927

---
A ledger is an append-only log that documents transactions. — location: [3892](kindle://book?action=open&asin=B09J2CMJZY&location=3892) ^ref-5128

---
The event-sourced domain model uses domain events exclusively for modeling the aggregates’ lifecycles. All changes to an aggregate’s state have to be expressed as domain events. — location: [3905](kindle://book?action=open&asin=B09J2CMJZY&location=3905) ^ref-4452

---
Each operation on an event-sourced aggregate follows this script: — location: [3906](kindle://book?action=open&asin=B09J2CMJZY&location=3906) ^ref-24222

---
Load the aggregate’s domain events. — location: [3907](kindle://book?action=open&asin=B09J2CMJZY&location=3907) ^ref-4543

---
Reconstitute a state representation—project — location: [3907](kindle://book?action=open&asin=B09J2CMJZY&location=3907) ^ref-14845

---
Execute the aggregate’s command to execute the business logic, and consequently, produce new domain events. — location: [3909](kindle://book?action=open&asin=B09J2CMJZY&location=3909) ^ref-22478

---
Commit the new domain events to the event store. — location: [3910](kindle://book?action=open&asin=B09J2CMJZY&location=3910) ^ref-38611

---
Contrary to the implementation we saw in the previous chapter, the event-sourced aggregate’s RequestEscalation method doesn’t explicitly set the IsEscalated flag to true. Instead, it instantiates the appropriate event and passes it to the AppendEvent method — location: [4013](kindle://book?action=open&asin=B09J2CMJZY&location=4013) ^ref-21903

---
Time traveling — location: [4109](kindle://book?action=open&asin=B09J2CMJZY&location=4109) ^ref-49056

---
Just as the domain events can be used to reconstitute an aggregate’s current state, they can also be used to restore all past states of the aggregate. — location: [4109](kindle://book?action=open&asin=B09J2CMJZY&location=4109) ^ref-10420

---
Deep insight — location: [4123](kindle://book?action=open&asin=B09J2CMJZY&location=4123) ^ref-54712

---
Event sourcing provides deep insight into the system’s state and behavior. — location: [4126](kindle://book?action=open&asin=B09J2CMJZY&location=4126) ^ref-22217

---
Audit log — location: [4129](kindle://book?action=open&asin=B09J2CMJZY&location=4129) ^ref-41340

---
The persisted domain events represent a strongly consistent audit log of everything that has happened to the aggregates’ states. — location: [4129](kindle://book?action=open&asin=B09J2CMJZY&location=4129) ^ref-568

---
Advanced optimistic concurrency management — location: [4134](kindle://book?action=open&asin=B09J2CMJZY&location=4134) ^ref-61619

---
When using event sourcing, we can gain deeper insight into exactly what has happened between reading the existing events and writing the new ones. — location: [4136](kindle://book?action=open&asin=B09J2CMJZY&location=4136) ^ref-13905

---
some of the challenges presented by the pattern: — location: [4146](kindle://book?action=open&asin=B09J2CMJZY&location=4146) ^ref-10223

---
Learning curve — location: [4147](kindle://book?action=open&asin=B09J2CMJZY&location=4147) ^ref-3482

---
Evolving the model — location: [4150](kindle://book?action=open&asin=B09J2CMJZY&location=4150) ^ref-11267

---
Evolving an event-sourced model can be challenging. — location: [4150](kindle://book?action=open&asin=B09J2CMJZY&location=4150) ^ref-63236

---
Architectural complexity — location: [4158](kindle://book?action=open&asin=B09J2CMJZY&location=4158) ^ref-17890

---
Implementation of event sources introduces numerous architectural “moving parts,” making the overall design more complicated. — location: [4158](kindle://book?action=open&asin=B09J2CMJZY&location=4158) ^ref-16237

---
In the rare cases when projecting states does become a performance issue, another pattern can be implemented: snapshot. This pattern, shown in Figure 7-2, implements the following steps: — location: [4176](kindle://book?action=open&asin=B09J2CMJZY&location=4176) ^ref-58826

---
A process continuously iterates new events in the event store, generates corresponding projections, and stores them in a cache. — location: [4183](kindle://book?action=open&asin=B09J2CMJZY&location=4183) ^ref-4560

---
The process fetches the current state projection from the cache. — location: [4185](kindle://book?action=open&asin=B09J2CMJZY&location=4185) ^ref-37651

---
The process fetches the events that came after the snapshot version from the event store. — location: [4186](kindle://book?action=open&asin=B09J2CMJZY&location=4186) ^ref-8027

---
The additional events are applied in-memory to the snapshot. — location: [4186](kindle://book?action=open&asin=B09J2CMJZY&location=4186) ^ref-28027

---
If the aggregates in your system won’t persist 10,000+ events, implementing the snapshot pattern is just an accidental complexity. — location: [4190](kindle://book?action=open&asin=B09J2CMJZY&location=4190) ^ref-40041

---
all events belonging to an instance of an aggregate should reside in a single shard (see Figure 7-3). — location: [4198](kindle://book?action=open&asin=B09J2CMJZY&location=4198) ^ref-5384

---
When the sensitive data has to be deleted, the encryption key is deleted from the key storage. As a result, the sensitive information contained in the events is no longer accessible. — location: [4223](kindle://book?action=open&asin=B09J2CMJZY&location=4223) ^ref-58586

---
It misses the business contexts: why the fields were changed. The lack of “why” drastically limits the ability to project additional models. — location: [4251](kindle://book?action=open&asin=B09J2CMJZY&location=4251) ^ref-21610

---
Layered architecture is one of the most common architectural patterns. It organizes the codebase into horizontal layers, with each layer addressing one of the following technical concerns: interaction with the consumers, implementing business logic, and persisting the data. — location: [4310](kindle://book?action=open&asin=B09J2CMJZY&location=4310) ^ref-64818

---
In its classic form, the layered architecture consists of three layers: the presentation layer (PL), the business logic layer (BLL), and the data access layer (DAL). — location: [4317](kindle://book?action=open&asin=B09J2CMJZY&location=4317) ^ref-50506

---
The presentation layer, shown in Figure 8-2, implements the program’s user interface for interactions with its consumers. — location: [4319](kindle://book?action=open&asin=B09J2CMJZY&location=4319) ^ref-55339

---
As the name suggests, this layer is responsible for implementing and encapsulating the program’s business logic. This is the place where business decisions are implemented. — location: [4334](kindle://book?action=open&asin=B09J2CMJZY&location=4334) ^ref-59468

---
The data access layer provides access to persistence mechanisms. — location: [4346](kindle://book?action=open&asin=B09J2CMJZY&location=4346) ^ref-57150

---
Finally, this layer also includes integration with the various external information providers needed to implement the program’s functionality: APIs provided by external systems, or cloud vendors’ managed services, — location: [4357](kindle://book?action=open&asin=B09J2CMJZY&location=4357) ^ref-34965

---
each layer can hold a dependency only on the layer directly beneath it, — location: [4367](kindle://book?action=open&asin=B09J2CMJZY&location=4367) ^ref-65245

---
the presentation layer references only the business logic layer. It has no knowledge of the design decisions made in the data access layer. — location: [4370](kindle://book?action=open&asin=B09J2CMJZY&location=4370) ^ref-15972

---
It’s common to see the layered architecture pattern extended with an additional layer: the service layer. — location: [4374](kindle://book?action=open&asin=B09J2CMJZY&location=4374) ^ref-35309

---
Defines an application’s boundary with a layer of services that establishes a set of available operations and coordinates the application’s response in each operation. — location: [4376](kindle://book?action=open&asin=B09J2CMJZY&location=4376) ^ref-47934

---
The service layer acts as an intermediary between the program’s presentation and business logic layers. — location: [4386](kindle://book?action=open&asin=B09J2CMJZY&location=4386) ^ref-37034

---
To further decouple the presentation layer from the underlying business logic, such orchestration logic can be moved into a service layer, — location: [4437](kindle://book?action=open&asin=B09J2CMJZY&location=4437) ^ref-60396

---
It’s important to note that in the context of the architectural pattern, the service layer is a logical boundary. It is not a physical service. — location: [4440](kindle://book?action=open&asin=B09J2CMJZY&location=4440) ^ref-64849

---
The service layer acts as a façade for the business logic layer: it exposes an interface that corresponds with the public interface’s methods, encapsulating the required orchestration of the underlying layers. — location: [4444](kindle://book?action=open&asin=B09J2CMJZY&location=4444) ^ref-63008

---
The presentation layer’s responsibility becomes limited to providing the required input to the service layer and communicating its responses back to the caller. — location: [4467](kindle://book?action=open&asin=B09J2CMJZY&location=4467) ^ref-24206

---
Having an explicit service level has a number of advantages: — location: [4533](kindle://book?action=open&asin=B09J2CMJZY&location=4533) ^ref-25152

---
We can reuse the same service layer to serve multiple public interfaces; for example, a graphical user interface and an API. No duplication of the orchestration logic is required. — location: [4534](kindle://book?action=open&asin=B09J2CMJZY&location=4534) ^ref-38925

---
It improves modularity by gathering all related methods in one place. — location: [4535](kindle://book?action=open&asin=B09J2CMJZY&location=4535) ^ref-46563

---
It further decouples the presentation and business logic layers. — location: [4536](kindle://book?action=open&asin=B09J2CMJZY&location=4536) ^ref-32641

---
It makes it easier to test the business functionality. — location: [4537](kindle://book?action=open&asin=B09J2CMJZY&location=4537) ^ref-25183

---
That said, a service layer is not always necessary. For example, when the business logic is implemented as a transaction script, it essentially is a service layer, as it already exposes a set of methods that form the system’s public interface. — location: [4538](kindle://book?action=open&asin=B09J2CMJZY&location=4538) ^ref-44801

---
Hence, either a service layer or a business logic layer will suffice. — location: [4540](kindle://book?action=open&asin=B09J2CMJZY&location=4540) ^ref-49724

---
On the other hand, the service layer is required if the business logic pattern requires external orchestration, as in the case of the active record pattern. — location: [4541](kindle://book?action=open&asin=B09J2CMJZY&location=4541) ^ref-7613

---
the pattern makes it challenging to implement a domain model. In a domain model, the business entities (aggregates and value objects) should have no dependency and no knowledge of the underlying infrastructure. — location: [4565](kindle://book?action=open&asin=B09J2CMJZY&location=4565) ^ref-33477

---
It is still possible to implement a domain model in a layered architecture, but the pattern we will discuss next fits much better. — location: [4570](kindle://book?action=open&asin=B09J2CMJZY&location=4570) ^ref-38921

---
The ports & adapters architecture addresses the shortcomings of the layered architecture and is a better fit for implementation of more complex business logic. — location: [4594](kindle://book?action=open&asin=B09J2CMJZY&location=4594) ^ref-62141

---
Essentially, both the presentation layer and data access layer represent integration with external components: databases, external services, and user interface frameworks. — location: [4601](kindle://book?action=open&asin=B09J2CMJZY&location=4601) ^ref-7185

---
let’s unify all such infrastructural concerns into a single “infrastructure layer,” — location: [4613](kindle://book?action=open&asin=B09J2CMJZY&location=4613) ^ref-43478

---
The dependency inversion principle (DIP) states that high-level modules, which implement the business logic, should not depend on low-level modules. However, that’s precisely what happens in the traditional layered architecture. The business logic layer depends on the infrastructure layer. — location: [4619](kindle://book?action=open&asin=B09J2CMJZY&location=4619) ^ref-10347

---
Instead of being sandwiched between the technological concerns, now the business logic layer takes the central role. It doesn’t depend on any of the system’s infrastructural components. — location: [4634](kindle://book?action=open&asin=B09J2CMJZY&location=4634) ^ref-27584

---
The architecture depicted in Figure 8-10 is the ports & adapters architectural pattern. — location: [4646](kindle://book?action=open&asin=B09J2CMJZY&location=4646) ^ref-64749

---
The core goal of the ports & adapters architecture is to decouple the system’s business logic from its infrastructural components. — location: [4651](kindle://book?action=open&asin=B09J2CMJZY&location=4651) ^ref-63401

---
The abstract ports are resolved into concrete adapters in the infrastructure layer, either through dependency injection or by bootstrapping. — location: [4665](kindle://book?action=open&asin=B09J2CMJZY&location=4665) ^ref-55675

---
The ports & adapters architecture is also known as hexagonal — location: [4687](kindle://book?action=open&asin=B09J2CMJZY&location=4687) ^ref-9071

---
architecture, onion architecture, and clean architecture. — location: [4687](kindle://book?action=open&asin=B09J2CMJZY&location=4687) ^ref-47517

---
Despite that, these patterns can be mistakenly treated as conceptually different. — location: [4693](kindle://book?action=open&asin=B09J2CMJZY&location=4693) ^ref-24226

---
The command-query responsibility segregation (CQRS) pattern is based on the same organizational principles for business logic and infrastructural concerns as ports & adapters. It differs, however, in the way the system’s data is managed. — location: [4701](kindle://book?action=open&asin=B09J2CMJZY&location=4701) ^ref-13321

---
An alternative to finding a perfect database is the polyglot persistence model: using multiple databases to implement different data-related requirements. — location: [4722](kindle://book?action=open&asin=B09J2CMJZY&location=4722) ^ref-13673

---
As the name suggests, the pattern segregates the responsibilities of the system’s models. There are two types of models: the command execution model and the read models. — location: [4732](kindle://book?action=open&asin=B09J2CMJZY&location=4732) ^ref-34909

---
The command execution model is also the only model representing strongly consistent data—the system’s source of truth. — location: [4743](kindle://book?action=open&asin=B09J2CMJZY&location=4743) ^ref-57445

---
Proper implementation of CQRS allows for wiping out all data of a projection and regenerating it from scratch. — location: [4752](kindle://book?action=open&asin=B09J2CMJZY&location=4752) ^ref-22575

---
Finally, read models are read-only. None of the system’s operations can directly modify the read models’ data. — location: [4754](kindle://book?action=open&asin=B09J2CMJZY&location=4754) ^ref-42930

---
For the read models to work, the system has to project changes from the command execution model to all its read models. — location: [4757](kindle://book?action=open&asin=B09J2CMJZY&location=4757) ^ref-31885

---
Synchronous projections fetch changes to the OLTP data through the catch-up subscription model: — location: [4768](kindle://book?action=open&asin=B09J2CMJZY&location=4768) ^ref-53318

---
Despite the apparent scaling and performance advantages of the asynchronous projection method, it is more prone to the challenges of distributed computing. — location: [4803](kindle://book?action=open&asin=B09J2CMJZY&location=4803) ^ref-40858

---
For these reasons, it’s advisable to always implement synchronous projection and, optionally, an additional asynchronous projection on top of it. — location: [4810](kindle://book?action=open&asin=B09J2CMJZY&location=4810) ^ref-44691

---
A common misconception about CQRS-based systems is that a command can only modify data, and data can be fetched for display only through a read model. In other words, the command executing the methods should never return any data. This is wrong. This approach produces accidental complexities and leads to a bad user experience. — location: [4819](kindle://book?action=open&asin=B09J2CMJZY&location=4819) ^ref-57473

---
command should always let the caller know whether it has succeeded or failed. If it has failed, why did it fail? Was there a validation or technical issue? The caller has to know how to fix the command. Therefore, a command can—and in many cases should—return data; for example, if the system’s user interface has to reflect the modifications resulting from the command. — location: [4821](kindle://book?action=open&asin=B09J2CMJZY&location=4821) ^ref-23231

---
The CQRS pattern can be useful for applications that need to work with the same data in multiple models, potentially stored in different kinds of databases. — location: [4829](kindle://book?action=open&asin=B09J2CMJZY&location=4829) ^ref-52199

---
Moreover, CQRS naturally lends itself to event-sourced domain models. — location: [4836](kindle://book?action=open&asin=B09J2CMJZY&location=4836) ^ref-19256

---
A bounded context is the boundary of a model—a ubiquitous language. — location: [4908](kindle://book?action=open&asin=B09J2CMJZY&location=4908) ^ref-59276

---
This translation can be handled by one, or sometimes both, sides: — location: [4924](kindle://book?action=open&asin=B09J2CMJZY&location=4924) ^ref-19378

---
The model’s translation logic can be either stateless or stateful. Stateless translation happens on the fly, as incoming (OHS) or outgoing (ACL) requests are issued, while stateful translation involves a more complicated translation logic that requires a database. — location: [4928](kindle://book?action=open&asin=B09J2CMJZY&location=4928) ^ref-41780

---
proxy design pattern to interject the incoming and outgoing requests and map the source model to the bounded context’s target model. — location: [4935](kindle://book?action=open&asin=B09J2CMJZY&location=4935) ^ref-45146

---
typical way to translate models used in synchronous communication is to embed the transformation logic in the bounded context’s codebase, — location: [4941](kindle://book?action=open&asin=B09J2CMJZY&location=4941) ^ref-41130

---
In an open-host service, translation to the public language takes place when processing incoming requests, and in an anticorruption layer, it occurs when calling the upstream bounded context. — location: [4944](kindle://book?action=open&asin=B09J2CMJZY&location=4944) ^ref-21126

---
In some cases, it can be more cost-effective and convenient to offload the translation logic to an external component such as an API gateway pattern. — location: [4948](kindle://book?action=open&asin=B09J2CMJZY&location=4948) ^ref-30426

---
Moreover, having an explicit API gateway can alleviate the process of managing and serving multiple versions of the bounded context’s API, as — location: [4952](kindle://book?action=open&asin=B09J2CMJZY&location=4952) ^ref-39749

---
Such bounded contexts, which are mainly in charge of transforming models for more convenient consumption by other components, are often referred to as interchange contexts. — location: [4960](kindle://book?action=open&asin=B09J2CMJZY&location=4960) ^ref-31466

---
To translate models used in asynchronous communication you can implement a message proxy: an intermediary component subscribing to messages coming from the source bounded context. — location: [4963](kindle://book?action=open&asin=B09J2CMJZY&location=4963) ^ref-56667

---
In addition to translating the messages’ model, the intercepting component can also reduce the noise on the target bounded context by filtering out irrelevant messages. — location: [4969](kindle://book?action=open&asin=B09J2CMJZY&location=4969) ^ref-11738

---
Asynchronous translation can be used to intercept the domain events and convert them into a published language, thus providing better encapsulation of the bounded context’s implementation details — location: [4972](kindle://book?action=open&asin=B09J2CMJZY&location=4972) ^ref-62725

---
translating messages to the published language enables differentiating between private events that are intended for the bounded context’s internal needs and public events that are designed for integration with other bounded contexts. — location: [4975](kindle://book?action=open&asin=B09J2CMJZY&location=4975) ^ref-59175

---
For more significant model transformations—for example, when the translation mechanism has to aggregate the source data or unify data from multiple sources into a single model—a stateful translation may be required. — location: [4985](kindle://book?action=open&asin=B09J2CMJZY&location=4985) ^ref-47481

---
To track the incoming data and process it accordingly, the translation logic requires its own persistent storage — location: [5000](kindle://book?action=open&asin=B09J2CMJZY&location=5000) ^ref-9331

---
In some use cases, you can avoid implementing a custom solution for a stateful translation by using off-the-shelf products; for example, a stream-process platform (Kafka, AWS Kinesis, etc.), or a batching solution (Apache NiFi, AWS Glue, Spark, etc.). — location: [5003](kindle://book?action=open&asin=B09J2CMJZY&location=5003) ^ref-65136

---
Publishing the domain event right from the aggregate is bad for two reasons. First, the event will be dispatched before the aggregate’s new state is committed to the database. — location: [5072](kindle://book?action=open&asin=B09J2CMJZY&location=5072) ^ref-60677

---
Second, what if the database transaction fails to commit because of a race condition, subsequent aggregate logic rendering the operation invalid, or simply a technical issue in the database? Even though the database transaction is rolled back, the event is already published and pushed to subscribers, and there is no way to retract it. — location: [5074](kindle://book?action=open&asin=B09J2CMJZY&location=5074) ^ref-13727

---
In the preceding listing, the responsibility of publishing new domain events is shifted to the application layer. — location: [5134](kindle://book?action=open&asin=B09J2CMJZY&location=5134) ^ref-41345

---
Can we trust this code? No. — location: [5138](kindle://book?action=open&asin=B09J2CMJZY&location=5138) ^ref-61334

---
The outbox pattern (Figure 9-11) ensures reliable publishing of domain events using the following algorithm: — location: [5143](kindle://book?action=open&asin=B09J2CMJZY&location=5143) ^ref-22843

---
Both the updated aggregate’s state and the new domain events are committed in the same atomic transaction. — location: [5149](kindle://book?action=open&asin=B09J2CMJZY&location=5149) ^ref-30732

---
A message relay fetches newly committed domain events from the database. — location: [5150](kindle://book?action=open&asin=B09J2CMJZY&location=5150) ^ref-12281

---
The relay publishes the domain events to the message bus. — location: [5151](kindle://book?action=open&asin=B09J2CMJZY&location=5151) ^ref-48177

---
Upon successful publishing, the relay either marks the events as published in the database or deletes them completely. — location: [5151](kindle://book?action=open&asin=B09J2CMJZY&location=5151) ^ref-60484

---
When using a relational database, it’s convenient to leverage the database’s ability to commit to two tables atomically and use a dedicated table for storing the messages, — location: [5155](kindle://book?action=open&asin=B09J2CMJZY&location=5155) ^ref-33712

---
When using a NoSQL database that doesn’t support multidocument transactions, the outgoing domain events have to be embedded in the aggregate’s record. — location: [5158](kindle://book?action=open&asin=B09J2CMJZY&location=5158) ^ref-61095

---
In this sample, you can see the JSON document’s additional property, outbox, containing a list of domain events that have to be published. — location: [5185](kindle://book?action=open&asin=B09J2CMJZY&location=5185) ^ref-55922

---
The publishing relay can fetch the new domain events in either a pull-based or push-based manner: — location: [5188](kindle://book?action=open&asin=B09J2CMJZY&location=5188) ^ref-13716

---
Pull: polling publisher — location: [5189](kindle://book?action=open&asin=B09J2CMJZY&location=5189) ^ref-17155

---
The relay can continuously query the database for unpublished events. — location: [5189](kindle://book?action=open&asin=B09J2CMJZY&location=5189) ^ref-4703

---
Proper indexes have to be in place to minimize the load on the database induced by the constant polling. — location: [5190](kindle://book?action=open&asin=B09J2CMJZY&location=5190) ^ref-10262

---
Push: transaction log tailing — location: [5190](kindle://book?action=open&asin=B09J2CMJZY&location=5190) ^ref-1845

---
Here we can leverage the database’s feature set to proactively call the publishing relay when new events are appended. — location: [5191](kindle://book?action=open&asin=B09J2CMJZY&location=5191) ^ref-27778

---
It’s important to note that the outbox pattern guarantees delivery of the messages at least once: if the relay fails right after publishing a message but before marking it as published in the database, the same message will be published again in the next iteration. — location: [5194](kindle://book?action=open&asin=B09J2CMJZY&location=5194) ^ref-65371

---
One of the core aggregate design principles is to limit each transaction to a single instance of an aggregate. — location: [5198](kindle://book?action=open&asin=B09J2CMJZY&location=5198) ^ref-50284

---
But there are cases when you have to implement a business process that spans multiple aggregates. — location: [5205](kindle://book?action=open&asin=B09J2CMJZY&location=5205) ^ref-32869

---
A saga is a long-running business process. It’s long running not necessarily in terms of time, as sagas can run from seconds to years, but rather in terms of transactions: a business process that spans multiple transactions. — location: [5213](kindle://book?action=open&asin=B09J2CMJZY&location=5213) ^ref-17078

---
The saga listens to the events emitted by the relevant components and issues subsequent commands to the other components. — location: [5217](kindle://book?action=open&asin=B09J2CMJZY&location=5217) ^ref-44254

---
If one of the execution steps fails, the saga is in charge of issuing relevant compensating actions to ensure the system state remains consistent. — location: [5217](kindle://book?action=open&asin=B09J2CMJZY&location=5217) ^ref-24969

---
Only the data within an aggregate’s boundaries can be considered strongly consistent. Everything outside is eventually consistent. — location: [5391](kindle://book?action=open&asin=B09J2CMJZY&location=5391) ^ref-38245

---
Business operations that have to belong to the same aggregate require strongly consistent data. — location: [5394](kindle://book?action=open&asin=B09J2CMJZY&location=5394) ^ref-11557

---
It is defined as a central processing unit that maintains the state of the sequence and determines the next processing steps.2 — location: [5417](kindle://book?action=open&asin=B09J2CMJZY&location=5417) ^ref-16838

---
As a simple rule of thumb, if a saga contains if-else statements to choose the correct course of action, it is probably a process manager. — location: [5421](kindle://book?action=open&asin=B09J2CMJZY&location=5421) ^ref-33030

---
Another difference between a process manager and a saga is that a saga is instantiated implicitly when a particular event is observed, as in CampaignActivated in the preceding examples. A process manager, on the other hand, cannot be bound to a single source event. Instead, it’s a coherent business process consisting of multiple steps. Hence, a process manager has to be instantiated explicitly. — location: [5422](kindle://book?action=open&asin=B09J2CMJZY&location=5422) ^ref-17084

---
The trip booking is the process and it has to be implemented as a process manager — location: [5429](kindle://book?action=open&asin=B09J2CMJZY&location=5429) ^ref-22427

---
From an implementation perspective, process managers are often implemented as aggregates, either state based or event — location: [5432](kindle://book?action=open&asin=B09J2CMJZY&location=5432) ^ref-58686

---
it’s a rule of thumb: not guaranteed to be perfect, yet sufficient for one’s immediate goals. In other words, using heuristics is an effective problem-solving approach that ignores the noise inherent in many cues, — location: [5656](kindle://book?action=open&asin=B09J2CMJZY&location=5656) ^ref-40435

---
There are many useful and revealing heuristics for defining the boundaries of a service. Size is one of the least useful. — location: [5671](kindle://book?action=open&asin=B09J2CMJZY&location=5671) ^ref-19087

---
Software changes affecting multiple bounded contexts are expensive and require lots of coordination, especially if the affected bounded contexts are implemented by different teams. — location: [5674](kindle://book?action=open&asin=B09J2CMJZY&location=5674) ^ref-50763

---
Such changes that are not encapsulated in a single bounded context signal ineffective design of the contexts’ boundaries. Unfortunately, refactoring bounded context boundaries is an expensive undertaking, — location: [5675](kindle://book?action=open&asin=B09J2CMJZY&location=5675) ^ref-64269

---
Hence, when designing bounded contexts, start with wider boundaries. If required, decompose the wide boundaries into smaller ones as you gain domain knowledge. — location: [5685](kindle://book?action=open&asin=B09J2CMJZY&location=5685) ^ref-33342

---
When creating a bounded context that contains a core subdomain, you can protect yourself against unforeseen changes by including other subdomains that the core subdomain interacts with most often. — location: [5688](kindle://book?action=open&asin=B09J2CMJZY&location=5688) ^ref-17148

---
Both the transaction script and active record patterns are better suited for subdomains with simple business logic: supporting subdomains or integrating a third-party solution for a generic subdomain, for example. — location: [5699](kindle://book?action=open&asin=B09J2CMJZY&location=5699) ^ref-21169

---
The difference between the two patterns is the complexity of the data structures. The transaction script pattern can be used for simple data structures, while the active record pattern helps to encapsulate the mapping of complex data structures to the underlying database. — location: [5708](kindle://book?action=open&asin=B09J2CMJZY&location=5708) ^ref-62523

---
Does the subdomain track money or other monetary transactions or have to provide a consistent audit log, or is deep analysis of its behavior required by the business? If so, use the event-sourced domain model. — location: [5721](kindle://book?action=open&asin=B09J2CMJZY&location=5721) ^ref-43606

---
Is the subdomain’s business logic complex? If so, implement a domain model. — location: [5723](kindle://book?action=open&asin=B09J2CMJZY&location=5723) ^ref-41275

---
Does the subdomain include complex data structures? If so, use the active record pattern. — location: [5724](kindle://book?action=open&asin=B09J2CMJZY&location=5724) ^ref-2074

---
Implement a transaction script. — location: [5725](kindle://book?action=open&asin=B09J2CMJZY&location=5725) ^ref-11009

---
A simple approach mainly revolves around validating the inputs. Another heuristic for evaluating complexity concerns the complexity of the ubiquitous language itself. Is it mainly describing CRUD operations, or is it describing more complicated business processes and rules? — location: [5731](kindle://book?action=open&asin=B09J2CMJZY&location=5731) ^ref-47903

---
The event-sourced domain model requires CQRS. — location: [5746](kindle://book?action=open&asin=B09J2CMJZY&location=5746) ^ref-2838

---
Otherwise, the system will be extremely limited in its data querying options, fetching a single instance by its ID only. — location: [5750](kindle://book?action=open&asin=B09J2CMJZY&location=5750) ^ref-915

---
The domain model requires the ports & adapters architecture. Otherwise, the layered architecture makes it hard to make aggregates and value objects ignorant of persistence. — location: [5751](kindle://book?action=open&asin=B09J2CMJZY&location=5751) ^ref-35898

---
The Active record pattern is best accompanied by a layered architecture with the additional application (service) layer. — location: [5756](kindle://book?action=open&asin=B09J2CMJZY&location=5756) ^ref-60864

---
The transaction script pattern can be implemented with a minimal layered architecture, consisting of only three layers. — location: [5758](kindle://book?action=open&asin=B09J2CMJZY&location=5758) ^ref-33786

---
The only exception to the preceding heuristics is the CQRS pattern. CQRS can be beneficial not only for the event-sourced domain model, but also for any other pattern if the subdomain requires representing its data in multiple persistent models. — location: [5761](kindle://book?action=open&asin=B09J2CMJZY&location=5761) ^ref-22912

---
The classic testing pyramid emphasizes unit tests, fewer integration tests, and even fewer end-to-end tests. — location: [5776](kindle://book?action=open&asin=B09J2CMJZY&location=5776) ^ref-52857

---
Both variants of the domain model patterns are best addressed with the testing pyramid. Aggregates and value objects make perfect units for effectively testing the business logic. — location: [5778](kindle://book?action=open&asin=B09J2CMJZY&location=5778) ^ref-54062

---
The testing diamond focuses the most on integration tests. When the active record pattern is used, the system’s business logic is, by definition, spread across both the service and business logic layers. — location: [5781](kindle://book?action=open&asin=B09J2CMJZY&location=5781) ^ref-27173

---
The reversed testing pyramid attributes the most attention to end-to-end tests: verifying the application’s workflow from beginning to end. Such an approach best fits codebases implementing the transaction script pattern: — location: [5785](kindle://book?action=open&asin=B09J2CMJZY&location=5785) ^ref-7294

---
At their core, both the transaction script and active record patterns are based on the same principle: the business logic is implemented as a procedural script. — location: [5967](kindle://book?action=open&asin=B09J2CMJZY&location=5967) ^ref-7736

---
the active record pattern introduces the data structures to encapsulate the complexity of mapping them to the storage mechanism. — location: [5974](kindle://book?action=open&asin=B09J2CMJZY&location=5974) ^ref-16539

---
when working with data becomes challenging in a transaction script, refactor it into the active record pattern. — location: [5975](kindle://book?action=open&asin=B09J2CMJZY&location=5975) ^ref-43136

---
If the business logic that manipulates active records becomes complex and you notice more and more cases of inconsistencies and duplications, refactor the implementation to the domain model pattern. — location: [5978](kindle://book?action=open&asin=B09J2CMJZY&location=5978) ^ref-54160

---
Start by identifying value objects. What data structures can be modeled as immutable objects? — location: [5985](kindle://book?action=open&asin=B09J2CMJZY&location=5985) ^ref-60636

---
Finally, for each aggregate, identify its root, or the entry point for its public interface. Make the methods of all the other internal objects in the aggregate private and only callable from within the aggregate. — location: [6083](kindle://book?action=open&asin=B09J2CMJZY&location=6083) ^ref-9514

---
The alternative approach is to acknowledge the lack of knowledge about past events and explicitly model it as an event. — location: [6167](kindle://book?action=open&asin=B09J2CMJZY&location=6167) ^ref-53297

---
